'''
Basic programming
-----------------
#1. Swap two numbers - Using Tuple ✅
#1a. Swap two numbers - Using a third variable ✅
#1b. Swap two numbers - Without using a third variable ✅
#2. Check if a number is prime number ✅
#2a. Check if a number is prime number - using math.sqrt() function, start range from 2 ✅
#3. Find factorial (non-recursion) ✅
#4. Fibonacci series (basic recursion) - Print Fibonacci Sequence: 0 1 1 2 3 5 ✅
#5. Print sum of elements in a list - Using for loop ✅
#5a. Print sum of elements in a list - Using for loop and range function ✅
#5b. Print sum of elements in a list - Using built in sum() method ✅
#6. Find Maximum & Minimum Element in an Array - Using for loop ✅
#6a. Find Maximum & Minimum Element in an Array - Using for loop and range function , range function print indices, compare with index ✅
#7. Find The index of Maximum & Minimum Element in an Array - list[i] = element, i = array index ✅
#8. Find the length of a list/Array - Using built in len() method ✅
#8a. Find the length of a list/Array - Using for loop ✅
#8b. Find the length of a list/Array - when list is created by user ✅
#9. Count specific word occurrences - Iterate through every element & indices ✅
#10. Swap first/last or any two elements in a list ✅
#11. Swap any two elements of a list ✅
#12. Remove the duplicate occurrence of words in a string and return a list ✅
#13. Remove the duplicate words from a string and return a string ✅
#14. Search an Element from a list - Using for loop ✅
#14a. Search an Element from a list - Using 'in' operator ✅
#15. Clear a list ✅
#16. Reverse a list - Using slicing ✅
#16a. Reverse a list - Using reverse() method ✅
#17. Clone/copy a list (5 approaches)
#18. Count occurrences of an element
#19. Multiply elements of a list
#20. 2nd largest/smallest element
#21. Check palindrome (word/string)
#22. Reverse words in a string ✅
#23. Substring search (and frequency)
#24. String length
#25. Sum of all odd/even numbers
#26. First repeating character in a string - break as soon as the first character is found ✅
#26a. All repeating character in a string - print out a list/tuple etc ✅
#26. First/all repeating character in a string ✅
#27. FizzBuzz
#28. Reverse a number
#29. First repeating character in a string - break as soon as the first character is found
#29a. All repeating character in a string - print out a list/tuple etc
#30. Add the first element with last element of two distinct list ✅
#31. Factorial using recursion ✅
#32. Remove duplicate words and return a string ✅
#32a. Remove duplicate words and return a list ✅
#33. Check for special characters using regex
#34. Check for URLs in strings using regex
#35. LRU Cache Implementation
     collections.OrderedDict or Custom LinkedList + HashMap approach.
#36. Multithreading in Python (threading module)
     Write a program that starts multiple threads to compute parts of a task.
#37. Producer-Consumer Problem using Queues
#38. Decorator Functions
     Implement a timing/decorator to log function performance.
#39. Using functools.reduce() and map() on a real problem
#40. Recursive Backtracking
     E.g. generating permutations, solving N-Queens.
#41. Custom Exception Handling
     Define custom errors for test validations.
#42. Use unittest or pytest
     Write end-to-end test for a Python module with mocking.
#43. Parsing JSON / XML / API response
     Useful for SDET testing pipelines.
#44. Writing Parameterized Tests with Pytest
#45. Database interaction using sqlite3

Leetcode: Arrays & Hashing : Easy
--------------------------------
1929. Concatenation of Array ✅
217. Contains Duplicate ✅
242. Valid Anagram ✅
1. Two Sum ✅
14. Longest Common Prefix ✅
27. Remove Element ✅

Leetcode: Arrays & Hashing : Medium
----------------------------------
242. Group Anagrams ✅
128. Longest Consecutive Sequence ✅

Leetcode: Two Pointers : Easy
-----------------------------
125. Valid Palindrome  ✅
680. Valid Palindrome II ✅

Leetcode: Sliding Window : Medium
----------------------------------
3. Longest Substring Without Repeating Characters ✅

AI recommendation for SDET
--------------------------
📁 Arrays & Hashing: Easy
-------------------------
1. Two Sum (#1) - array + hashmap ✅
2. Contains Duplicate (#217) ✅
3. Intersection of Two Arrays (#349)
4. Majority Element (#169)
5. Product of Array Except Self (#238)
6. Top K Frequent Elements (#347)
7. Find Missing Number / Missing Ranges (#268 / #163)
8. Longest Consecutive Sequence (#128) ✅

📁 Arrays & Hashing: Medium
---------------------------
9. Subarray Sum Equals K (#560)
10. 3Sum (#15) 
11. Group Anagrams (#49) ✅
12. Top K Frequent Words (#692)
13. Longest Subarray with Equal 0s and 1s (#525)
14. Maximum Size Subarray Sum Equals K (variation of #560)

🔤 Strings & Sliding Window: Easy
---------------------------------
15. Valid Anagram (#242) ✅
16. First Unique Character in a String (#387)
17. Reverse String (#344)
18. Valid Palindrome (#125)
19. Implement strStr() (#28)
20. Count and Say (#38)

🔤 Strings & Sliding Window: Medium
-----------------------------------
21. Longest Substring Without Repeating Characters (#3) ✅
22. Minimum Window Substring (#76)
23. Longest Repeating Character Replacement (#424)
24. Valid Parentheses (#20)
25. Longest Palindromic Substring (#5)
26. Find All Anagrams in a String (#438)

🔁 Two Pointers, Sorting & Intervals: Easy
------------------------------------------
27. Move Zeroes (#283)
28. 2Sum II - Input array sorted (#167)
29. Merge Sorted Array (#88)
30. Valid Palindrome II (#680) ✅
31. Container With Most Water (#11)

🔁 Two Pointers, Sorting & Intervals: Medium
--------------------------------------------
32. Sort Colors (Dutch Flag) (#75)
33. 3Sum Closest (#16)
34. Remove Duplicates from Sorted Array (#26)
35. Intersection of Two Arrays II (#350)
36. Merge Intervals (#56)

🗂 Stacks & Queues: Easy
------------------------
37. Valid Parentheses (#20)
38. Min Stack (#155)
39. Implement Queue using Stacks (#232)

🗂 Stacks & Queues: Medium
--------------------------
40. Next Greater Element (#496)
41. Sliding Window Maximum (#239)
42. Evaluate Reverse Polish Notation (#150)

🔁 Recursion & Backtracking (Basic): Easy
-----------------------------------------
43. Fibonacci Number (#509)
44. Factorial recursion or Sum of Digits (not official LeetCode)
45. Sum of digits (custom but base recursion problem)

🔁 Recursion & Backtracking (Basic): Medium
-------------------------------------------
46. Generate Parentheses (#22)
47. Subsets (#78)
48. Combinations (#77)
49. Word Search (#79)

🔍 Binary Search & Matrix: Easy
-------------------------------
50. Binary Search (#704)
51. Search Insert Position (#35)
52. Guess Number Higher or Lower (#374)
53. Find First and Last Position of Element (#34)

🔍 Binary Search & Matrix: Medium
---------------------------------
54. Search a 2D Matrix (#74)
55. Kth Smallest Element in a Sorted Matrix (#378)
56. Divide Two Integers (#29)

🌳 Binary Tree & Graph (Optional mostly): Medium
------------------------------------------------
57. Maximum Depth of Binary Tree (#104)
58. Same Tree / Symmetric Tree (#100 / #101)
59. Binary Tree Level Order Traversal (#102)
60. Validate Binary Search Tree (#98)

🌳 Binary Tree & Graph (Optional extra senior topics): Medium
-------------------------------------------------------------
61. Lowest Common Ancestor (#236)
62. Course Schedule (Graph) (#207)

➕ Bit Manipulation & Math: Easy
--------------------------------
63. Single Number (#136)
64. Hamming Distance (#461)
65. Power of Two (#231)

➕ Bit Manipulation & Math: Medium
----------------------------------
67. Count Bits (#338)
68. Number of 1 Bits (#191)
69. Bits manipulation variants (e.g. #190 or #137)
'''

# Basic programming
# -----------------
#1. Swap two numbers - Using Tuple
num1 = int(input('Enter the first number: '))
num2 = int(input('Enter the second number: '))

print('First number: ', num1)
print('Second number: ', num2)

num1, num2 = num2, num1

print('After swapping')
print('First number: ', num1)
print('Second number: ', num2)


#1a. Swap two numbers - Using a third variable
num1 = int(input('Enter the first number: '))
num2 = int(input('Enter the second number: '))

print('First number: ', num1)
print('Second number: ', num2)

num3 = num1
num1 = num2
num2 = num3

print('After swapping')
print('First number: ', num1)
print('Second number: ', num2)

#1b. Swap two numbers - Without using a third variable
num1 = int(input('Enter the first number: '))
num2 = int(input('Enter the second number: '))

print('First number: ', num1)
print('Second number: ', num2)

num1 = num1 + num2
num2 = num1 - num2
num1 = num1 - num2

print('After swapping')
print('First number: ', num1)
print('Second number: ', num2)

#2. Check if a number is prime number
num = int(input("Enter a number: "))
count = 0

if num <= 1:
    print(f'{num} is not a prime number')
else:
    for i in range(1, num+1):
        if num%i == 0:
            count = count + 1

    if count == 2:
        print(f'{num} is a prime number')
    else:
        print(f'{num} is not a prime number')

#2a. Check if a number is prime number - using math.sqrt() function, start range from 2
import math
num = int(input("Enter a number: "))

count = 0

if num <= 1:
    print(f'{num} is not a prime number')
else:
    for i in range(2, int(math.sqrt(num)) + 1):
        if num%i == 0:
            print(f'{num} is not a prime number')
            break
    # else after for runs only if the loop completes without break
    else:
        print(f'{num} is a prime number')

#3. Find factorial (non-recursion)
num = int(input("Enter a number: "))

def factorial(num):
    factorial = 1
    if num < 0:
        return (f'There is not factorial for {num}')
    elif num == 0 or num == 1:
        return 1
    else:
        for i in range(1, num+1):
            factorial = factorial * i
        return factorial

print(factorial(num))

#4. Fibonacci series (basic recursion) - Print Fibonacci Sequence: 0 1 1 2 3 5
def fibonacci(num):
    if num < 0 or num == 0:
        return 0
    elif num == 1:
        return 1
    else:
        return fibonacci(num-1) + fibonacci(num-2)

while True:
    numberOfTerms = int(input("Enter the number of terms: "))
    if numberOfTerms > 0:
        for i in range(numberOfTerms):
            print(fibonacci(i))
        break
    else:
        print("Enter a positive number")

#5. Print sum of elements in a list - Using for loop
arr = [10, 20, 30, 40, 50]
total = 0

for i in arr:
    total = total + i

print(sum)

#5a. Print sum of elements in a list - Using for loop and range function
arr = [10, 20, 30, 40, 50]
total = 0

for i in range(len(arr)):
    total = total + arr[i]

print(sum)

#5b. Print sum of elements in a list - Using built in sum() method
arr = [10, 20, 30, 40, 50]
print(sum(arr))

#6. Find Maximum & Minimum Element in an Array - Using for loop
arr = [10, 50, 200, 40, 3]
max = arr[0]
min = arr[0]

for i in arr:
    if i > max:
        max = i
    if i < min:
        min = i

print(f'The max value is {max}')
print(f'The min value is {min}')

#6a. Find Maximum & Minimum Element in an Array - Using for loop and range function , range function print indices, compare with index
arr = [10, 50, 200, 40, 3]
max = arr[0]
min = arr[0]

for i in range(len(arr)):
    if arr[i] > max:
        max = arr[i]
    if arr[i] < min:
        min = arr[i]

print(f'The max value is {max}')
print(f'The min value is {min}')

#7. Find The index of Maximum & Minimum Element in an Array - list[i] = element, i = array index
list = [10, 20, 13, 2, 200, 19]

max_index = 0
min_index = 0

for i in range(len(list)):
    if list[i] > list[max_index]:
        max_index = i
    if list[i] < list[min_index]:
        min_index = i

print(f'The index of the maximum number is: {max_index}')
print('The index of the minimum number is:', min_index)

#8. Find the length of a list/Array - Using built in len() method
arr = [10, 300, 20, 400, 50, 70]
print(len(arr))

#8a. Find the length of a list/Array - Using for loop
arr = [10, 300, 20, 400, 50, 70]
count = 0

for i in arr:
    count += 1

print('The total number of elements in the list is', count)

#8b. Find the length of a list/Array - when list is created by user
userList = input("Enter the numbers separated by space: ")
total = userList.split()
print(len(total))

#9. Count specific word occurrences - Iterate through every element & indices
str = "my name is sunny giving interview sunny knows python"
count = 0
count1 = 0

list = str.split()

# Iterate through every element
for i in list:
    if i == 'sunny':
        count += 1

#Iterate though indices
for i in range(len(list)):
    if list[i] == 'sunny':
        count1 += 1

print(count)
print(count1)

#10. Swap first/last or any two elements in a list
arr = [12, 35, 9, 56, 24]
print(arr[0])
print(arr[-1])

arr[0], arr[-1] = arr[-1], arr[0]
print(arr[0])
print(arr[-1])

#11. Swap any two elements of a list
arr = [12, 35, 9, 56, 24]
print(arr[1])
print(arr[3])

# swap position 2 with 4
arr[1], arr[3] = arr[3], arr[1]
print(arr[1])
print(arr[3])

#12. Remove the duplicate occurrence of words in a string and return a list
input_str = input("Enter words separated by spaces: ")
uniqueWords = set(input_str.split())
print(list(uniqueWords))

#13. Remove the duplicate words from a string and return a string
input_str = input("Enter words separated by spaces: ")
print(input_str)
newStr = set(input_str.split())
print(newStr)
print(" ".join(newStr))

#14. Search an Element from a list - Using for loop
myList = [12, 222, 34, 4, 5]
num = int(input("What number do you want to find? "))

for i in myList:
    if num == i:
        print('Element found')
        break
else:
    print(f'Element not found')

#14a. Search an Element from a list - Using 'in' operator
myList = [12, 222, 34, 4, 5]

num = int(input("What number do you want to find? "))

if num in myList:
    print(f'Element found')
else:
    print(f'Element not found')

#15. Clear a list
myList = [1, 6, 3, 5, 3, 4]
print('Before clearing the list', myList)
myList.clear()
print('After clearing the list', myList)

#16. Reverse a list - Using slicing 
myList = [1, 6, 3, 5, 3, 4]
print('Before reversing', myList)
reversedList = myList[::-1]
print('After reversing', reversedList)

#16a. Reverse a list - Using reverse() method
myList = [1, 6, 3, 5, 3, 4]
print('Before reversing', myList)
myList.reverse()
print('After reversing', myList)

#17. Clone/copy a list (5 approaches)

#18. Count occurrences of an element

#19. Multiply elements of a list

#20. 2nd largest/smallest element

#21. Check palindrome (word/string)
s = "madam madam"

def isPalindrome(s):
    if s == s[::-1]:
        return True
    else:
        return False

print(isPalindrome(s))

#22. Reverse words in a string
string = input("Enter the words of string seperated by comma: ")
print(string)
newString = string.split(" ")
reverse_word = " ".join(newString[::-1])
print("The reverses string is: ", reverse_word)

#23. Substring search (and frequency)

#24. String length

#25. Sum of all odd/even numbers

#26. First repeating character in a string - break as soon as the first character is found
s = "aabcde"
repeatedCharacter = set()

for c in s:
    if s.count(c) > 1:
        repeatedCharacter.add(c)
        break

if len(repeatedCharacter) > 0:
    print('The first repeated character is', list(repeatedCharacter)[0])
else:
    print('There is no repeacting character')

#26a. All repeating character in a string - print out a list/tuple etc
s = "aabbcde"
repeatedCharacter = set()

for c in s:
    if s.count(c) > 1:
        repeatedCharacter.add(c)

if len(repeatedCharacter) > 0:
    print('The first repeated character is', list(repeatedCharacter))
else:
    print('There is no repeacting character')

#27. FizzBuzz

#28. Reverse a number

#29. First repeating character in a string - break as soon as the first character is found

#29a. All repeating character in a string - print out a list/tuple etc

#30. Add the first element with last element of two distinct list
listOne = [1, 2, 3, 4, 5]
listTwo = [6, 7, 8, 9, 10]
newList = []

for i in range(len(listOne)):
    newList.append(listOne[i] + listTwo[len(listTwo) - i - 1])

print(newList)

#31. Factorial using recursion
num = int(input("Enter a number: "))

def factorial(num):
    if num < 0:
        return f"no factorial for {num}"
    elif num == 0 or num == 1:
        return 1
    else:
        return num * factorial(num-1)

print(factorial(num))

#32. Remove duplicate words and return a string
string = input("Enter the words of string seperated by comma: ")
print(string)
newString = set(string.split())
print(newString)

#32a. Remove duplicate words and return a list
string = input("Enter the words of string seperated by comma: ")
print(string)
newString = set(string.split())
print(list(newString))

#33. Check for special characters using regex

#34. Check for URLs in strings using regex

#Leetcode: Arrays & Hashing : Easy
#---------------------------------
#1929. Concatenation of Array - Nested for loop with append()
nums = [1,3,2,1]
ans = []
iteration = int(input('Enter the number of times you want to concatenate the array: '))

def concatenationOfArray(nums, x):
    for i in range(x):
        for i in nums:
            ans.append(i)

    return ans

print(concatenationOfArray(nums,iteration))

#217. Contains Duplicate - Use set()
nums = [1,2,3,1]

def containDuplicate(nums):
    hashset = set()
    for i in nums:
        if i in hashset:
            return True
        hashset.add(i)
    return False

print(containDuplicate(nums))

#242. Valid Anagram - Counter method
from collections import Counter
s = "anagram"
t = "nagaram"

def validAnagram(s, t):
    return Counter(s) == Counter(t)

print(validAnagram(s, t))

#242a. Valid Anagram - Sorted method
s = "anagram"
t = "nagaram"

def validAnagram(s, t):
    return sorted(s) == sorted(t)

print(validAnagram(s, t))

#242b. Valid Anagram - Using hasmap algorithm, use .get(key, default)
s = "anagram"
t = "nagaram"

def validAnagram(s, t):
    if len(s) != len(t):
        return False
    
    # create a hashmap/dictionary
    count = {} 

    # add all they keys and values into the hashmap
    for char in s:
        count[char] = count.get(char, 0) + 1

    # check the keys from string t with the hashmap and delete one key at a time
    for char in t:
        if char not in count:
            return False
        count[char] -= 1
        if count[char] < 0:
            return False
    
    return True

print(validAnagram(s, t))

#1. Two Sum - {value: index}, storing the value as the key and the index as the value
nums = [2,7,11,15]
target = 9

def twoSum(nums, target):
    prevMap = {}
    for index, number in enumerate(nums):
        diff = target - number
        if diff in prevMap:
            return prevMap[diff], index
        prevMap[number] = index

print(twoSum(nums, target))

#14. Longest Common Prefix
strs = ["flower","flow","flight"]

def longestCommonPrefix(strs):
    res = ""
    for i in range(len(strs[0])):
        for s in strs:
            if i == len(s) or s[i] != strs[0][i]:
                return res
        res += strs[0][i]
    
    return res

print(longestCommonPrefix(strs))

#27. Remove Element
nums = [0,1,2,2,3,0,4,2]
val = 2

def removeElement(nums, val):
    k = 0
    for i in range(len(nums)):
        if nums[i] != val:
            nums[k] = nums[i]
            k += 1
    return k

print(removeElement(nums, val))

#Leetcode: Arrays & Hashing : Medium
#---------------------------------
#242. Group Anagrams - Use dict, ord(), array of 26 characters
from collections import defaultdict

strs = ["eat","tea","tan","ate","nat","bat"]
res = defaultdict(list)   # creates an empty list as a default value, no need to create a key

def validGroupAnagram(strs):
    for s in strs:
        count = [0] * 26
        for c in s:
            count[ord(c) - ord("a")] +=1  # Map 'a' - 'z' to idex 0 - 25
        res[tuple(count)].append(s)
    return list(res.values())

print(validGroupAnagram(strs))

#128. Longest Consecutive Sequence - Use set(), check left number
nums = [1,0,1,2]
hashSet = set(nums)

def longestConsecutiveSequence(nums):
    longest = 0
    length = 0
    for n in nums:
        if (n - 1) not in hashSet:
            length = 1
        while (n + length) in hashSet:
            length += 1
        longest = max(longest, length)
    return longest

print(longestConsecutiveSequence(nums))

#Leetcode: Two Pointers : Easy
#-----------------------------
#125. Valid Palindrome - Two pointers with alphanum validation
s = "A man, a plan, a canal: Panama"

def alphaNum(s):
    return (ord('A') <= ord(s) <= ord('Z') or ord('a') <= ord(s) <= ord('z') or (ord('0') <= ord(s) <= ord('9')))

def isPalindrome(s):
    left, right = 0, len(s) - 1 
    while left < right:
        # Move left pointer until an alphanumeric character is found
        # not alphaNumber function skip over any non alphanumeric character
        while left < right and not alphaNum(s[left]):
            left += 1
        # Move right pointer until an alphanumeric character is found
        while right > left and not alphaNum(s[right]):
            right -= 1
        # Check if characters are not equal (ignoring case)
        if s[left].lower() != s[right].lower():
            return False
        # Move both pointers towards the center
        left += 1
        right -= 1

    return True

print(isPalindrome(s))

#125a. Valid Palindrome - Two pointers with alphanum validation
s = "A man, a plan, a canal: Panama"
def validPalindrome(s):
    newStr = ""
    for c in s:
        if c.isalnum():
            newStr += c.lower()
    return newStr == newStr[::-1]

print(validPalindrome(s))

#680. Valid Palindrome II
s = "racecarx"

def validPalindromeHelper(s, left, right):
    while left < right: 
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

def validPalindromeTwo(s):
    left = 0
    right = len(s) - 1
    while left < right:
        return validPalindromeHelper(s, left + 1, right) or validPalindromeHelper(s, left, right - 1)
        left += 1
        right -= 1
    return True

print(validPalindromeTwo(s))

#Leetcode: Sliding Window : Medium
#----------------------------------
#3. Longest Substring Without Repeating Characters
s = "abcabcbb"

def longestSubstingWithoutReapeatingCharacters(s):
    charSet = set()
    l = 0
    res = 0

    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)

    return res

print(longestSubstingWithoutReapeatingCharacters(s))